# 모의고사(완전탐색)

![스크린샷 2023-03-06 오전 1.23.15.png](%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1(%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8)%209aca8e862f3049bf9f1f4e71817dc4c3/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.23.15.png)

```python
def solution(answers):
    answer = []
    person = [0] * 3 # 3명의 수포자가 맞춘 개수를 넣을 리스트
    a1 = [1, 2, 3, 4, 5] # 1번째 수포자의 답을 넣은 리스트
    a2 = [2, 1, 2, 3, 2, 4, 2, 5] # 2번째 수포자의 답을 넣은 리스트
    a3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] # 3번째 수포자의 답을 넣은 리스트

    # 맞춘 개수를 확인하는 코드
    for i in range(len(answers)):
        # 1번째 수포자는 5개의 답이 반복되므로 [i%5] 해줌
        if answers[i] == a1[i%5]:
            person[0] += 1
        # 2번째 수포자는 8개의 답이 반복되므로 [i%5] 해줌
        if answers[i] == a2[i%8]:
            person[1] += 1
        # 3번째 수포자는 10개의 답이 반복되므로 [i%5] 해줌
        if answers[i] == a3[i%10]:
            person[2] += 1

    winner = max(person) # 가장 많이 맞춘 사람의 개수를 넣는 변수 
    # 가장 많이 맞춘 사람을 넣는 코드 (공동 1등이 나올 수 있으므로)
    for i in range(len(person)):
        if person[i] == winner:
            answer.append(i+1)
    return answer
```

첫번째 answer빈 리스트를 생성한다

person = [0,0,0]으로 초기화한다

(3명이므로 3개를 하였다) >>이거는 3명의 수포자가 맞춘 개수를 넣을 리스트이다!!

그 다음 이 1,2,3번 수포자들의 찍는 방식이 반복되므로 반복이 끝나는 지점까지 각 리스트에 할당해서 변수에 넣어준다

그 다음 for구문으로 len(answer)을 돌려서 만약 answer[i]와 수포자들[i%] 이거는 각각 반복되는 그 기준이 다르므로 %뒤에 숫자는 다르게. 수포자a1,a2,a3이런식으로 분리해서

1번 수포자가 맞춘 개수는 person[0]에 2번은[1]에 3번은[2]에  할당해 주었다

여기서 가장 많은 숫자가 있는 인덱스가 수포자 중 가장 많이 맞춘 횟수이므로

max(person)으로 최대 수를 winner에 넣어주었다

그러면 winner는 가장 많이 맞춘 개수를 가지고 있으므로

for문으로 person을 돌려서 그 맞춘횟수의 인덱스를 찾아주면 몇번으 수포자가 가장 많이 맞췄는지 알 수 있다